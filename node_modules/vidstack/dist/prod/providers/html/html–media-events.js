import { effect, onDispose } from 'maverick.js';
import { useDisposalBin, listenEvent, DOMEvent, isNil } from 'maverick.js/std';
import { R as RAFLoop } from '../hls/hls.js';
import { i as isHLSSrc } from '../audio/loader.js';
import { y as getNumberOfDecimalPlaces } from '../../media-ui.js';
import { I as IS_SAFARI } from '../../media-core.js';

class HTMLMediaEvents {
  constructor(_provider, _context) {
    this.q = _provider;
    this.ph = _context;
    this.Uh();
    effect(this.Vh.bind(this));
    onDispose(this.Eh.bind(this));
  }
  ih = useDisposalBin();
  Nh = false;
  Qh = false;
  Rh = false;
  Oh = new RAFLoop(this.Wh.bind(this));
  get j() {
    return this.q.media;
  }
  get jg() {
    return this.ph.delegate;
  }
  Eh() {
    this.Oh.P();
    this.ih.empty();
  }
  /**
   * The `timeupdate` event fires surprisingly infrequently during playback, meaning your progress
   * bar (or whatever else is synced to the currentTime) moves in a choppy fashion. This helps
   * resolve that by retrieving time updates in a request animation frame loop.
   */
  Wh() {
    const newTime = this.q.currentTime;
    if (this.ph.$store.currentTime() !== newTime)
      this.Mh(newTime);
  }
  Uh() {
    this.Lh("loadstart", this.ge);
    this.Lh("abort", this.Sh);
    this.Lh("emptied", this.Xh);
    this.Lh("error", this.Wb);
  }
  Yh() {
    if (this.Qh)
      return;
    this.ih.add(
      this.Lh("loadeddata", this.Zh),
      this.Lh("loadedmetadata", this._h),
      this.Lh("canplay", this.Rb),
      this.Lh("canplaythrough", this.$h),
      this.Lh("durationchange", this.ai),
      this.Lh("play", this.bi),
      this.Lh("progress", this.ci),
      this.Lh("stalled", this.di),
      this.Lh("suspend", this.ei)
    );
    this.Qh = true;
  }
  fi() {
    if (this.Rh)
      return;
    this.ih.add(
      this.Lh("pause", this.gi),
      this.Lh("playing", this.hi),
      this.Lh("ratechange", this.ii),
      this.Lh("seeked", this.ji),
      this.Lh("seeking", this.ki),
      this.Lh("ended", this.li),
      this.Lh("volumechange", this.ac),
      this.Lh("waiting", this.mi)
    );
    this.Rh = true;
  }
  ni = void 0;
  pi = void 0;
  Lh(eventType, handler) {
    return listenEvent(
      this.j,
      eventType,
      handler.bind(this)
    );
  }
  qi(event2) {
    return;
  }
  Mh(time, trigger) {
    this.jg.p("time-update", {
      // Avoid errors where `currentTime` can have higher precision.
      detail: {
        currentTime: Math.min(time, this.ph.$store.seekableEnd()),
        played: this.j.played
      },
      trigger
    });
  }
  ge(event2) {
    if (this.j.networkState === 3) {
      this.Sh(event2);
      return;
    }
    this.Yh();
    this.jg.p("load-start", { trigger: event2 });
  }
  Sh(event2) {
    this.jg.p("abort", { trigger: event2 });
  }
  Xh() {
    this.jg.p("emptied", { trigger: event });
  }
  Zh(event2) {
    this.jg.p("loaded-data", { trigger: event2 });
  }
  _h(event2) {
    this.Th();
    this.fi();
    this.jg.p("volume-change", {
      detail: {
        volume: this.j.volume,
        muted: this.j.muted
      }
    });
    this.jg.p("loaded-metadata", { trigger: event2 });
    if (IS_SAFARI && isHLSSrc(this.ph.$store.source())) {
      this.jg.lf(this.Ph(), event2);
    }
  }
  Ph() {
    return {
      duration: this.j.duration,
      buffered: this.j.buffered,
      seekable: this.j.seekable
    };
  }
  Th() {
    const isLive = !Number.isFinite(this.j.duration);
    this.jg.p("stream-type-change", {
      detail: isLive ? "live" : "on-demand"
    });
  }
  bi(event2) {
    if (!this.ph.$store.canPlay)
      return;
    this.jg.p("play", { trigger: event2 });
  }
  gi(event2) {
    if (this.j.readyState === 1 && !this.Nh)
      return;
    this.Nh = false;
    this.Oh.P();
    this.jg.p("pause", { trigger: event2 });
  }
  Rb(event2) {
    this.jg.lf(this.Ph(), event2);
  }
  $h(event2) {
    if (this.ph.$store.started())
      return;
    this.jg.p("can-play-through", {
      trigger: event2,
      detail: this.Ph()
    });
  }
  hi(event2) {
    this.Nh = false;
    this.jg.p("playing", { trigger: event2 });
    this.Oh.O();
  }
  di(event2) {
    this.jg.p("stalled", { trigger: event2 });
    if (this.j.readyState < 3) {
      this.Nh = true;
      this.jg.p("waiting", { trigger: event2 });
    }
  }
  mi(event2) {
    if (this.j.readyState < 3) {
      this.Nh = true;
      this.jg.p("waiting", { trigger: event2 });
    }
  }
  li(event2) {
    this.Oh.P();
    this.Mh(this.j.duration, event2);
    this.jg.p("end", { trigger: event2 });
    if (this.ph.$store.loop()) {
      this.oi();
    } else {
      this.jg.p("ended", { trigger: event2 });
    }
  }
  Vh() {
    if (this.ph.$store.paused()) {
      listenEvent(this.j, "timeupdate", this.Vb.bind(this));
    }
  }
  Vb(event2) {
    this.Mh(this.j.currentTime, event2);
  }
  ai(event2) {
    this.Th();
    if (this.ph.$store.ended()) {
      this.Mh(this.j.duration, event2);
    }
    this.jg.p("duration-change", {
      detail: this.j.duration,
      trigger: event2
    });
  }
  ac(event2) {
    this.jg.p("volume-change", {
      detail: {
        volume: this.j.volume,
        muted: this.j.muted
      },
      trigger: event2
    });
  }
  ji(event2) {
    this.Mh(this.j.currentTime, event2);
    this.jg.p("seeked", {
      detail: this.j.currentTime,
      trigger: event2
    });
    if (Math.trunc(this.j.currentTime) === Math.trunc(this.j.duration) && getNumberOfDecimalPlaces(this.j.duration) > getNumberOfDecimalPlaces(this.j.currentTime)) {
      this.Mh(this.j.duration, event2);
      if (!this.j.ended) {
        this.ph.player.dispatchEvent(
          new DOMEvent("media-play-request", {
            trigger: event2
          })
        );
      }
    }
  }
  ki(event2) {
    this.jg.p("seeking", {
      detail: this.j.currentTime,
      trigger: event2
    });
  }
  ci(event2) {
    this.jg.p("progress", {
      detail: {
        buffered: this.j.buffered,
        seekable: this.j.seekable
      },
      trigger: event2
    });
  }
  oi() {
    const hasCustomControls = isNil(this.j.controls);
    if (hasCustomControls)
      this.j.controls = false;
    this.ph.player.dispatchEvent(new DOMEvent("media-loop-request"));
  }
  ei(event2) {
    this.jg.p("suspend", { trigger: event2 });
  }
  ii(event2) {
    this.jg.p("rate-change", {
      detail: this.j.playbackRate,
      trigger: event2
    });
  }
  Wb(event2) {
    const error = this.j.error;
    if (!error)
      return;
    this.jg.p("error", {
      detail: {
        message: error.message,
        code: error.code,
        mediaError: error
      },
      trigger: event2
    });
  }
}

export { HTMLMediaEvents as H };
